LIGHT-DARK or USER-HOST or CLIENT-SERVER

single-session

layout of variant is separate from the rules/script; the layout of piles is of no concern to DARK

DARK knows nothing of ebiten or gg

LIGHT is really stupid. It's passed an entire baize of cards,
and lerps the difference between old and new.

TODO
====
[ ] Stock tapped cards are not always flipping
	seems okay with -noload/-nosave
[ ] get rid of the scrunch loop
	Q. How do we do scrunch in gosol?
	A. if the card positions are dirty, scrunch is called on each pile
		scrunch works out the maximum pile size
		then, starting from the max/default fan factor
		the fan factor is reduced, the cards refanned, until the cards fit in the max pile size
	Q. How do we do scrunch in lsol?
	A.
[ ] Given a sequence, the function continuously splits the sequence into a head and a tail. Then it processes the head, adds it to some result, and uses recursion to continue the process with the tail.
[ ] Stock and pile tap in Robot()?
	certainly in Solver
[ ] Do all the Hapgood variants
	requires rotating cards
	which only gets tricky when fanned
	and choose an origin to rotate about
[ ] go Solve() when weights are 1
	Robot() when there are weights > 1
[ ] https://garden.bradwoods.io/notes/design/juice
	fly-away % complete, that animates upward from the card dst?
[ ] Robot()
	only do one round in case of circulars
	36x36 white robot/wizard/assist icon
[x] why save >1 tap target for each card? just makes the solver more complicated.
[x] packs, suits in ScriptBase AND Stock!?
[x] only calc Baize crc when it's needed, only use Baize.crc in solver
[ ] WASM
[ ] Mirror Baize
[x] dark makeTail failing after loading a game
[x] recenter variant in toolbar after changing it

TAP DESTINATIONS
================
foreach pile
	Pile vtable MovableTails2() [][]*Card
		if cell or reserve or waste or stock, make a []tail of just top card
		if foundation or discard, make empty/nil tail
		if tableau, return list of pile.canMoveTail/script.TailMoveError tails

	consolidate the lists with Baize findAllMovableTails2()

	foreach tail from above, make a list of piles where a tap would send that tail
	using baize.findHomesForTail

	so each card now has a list of tap destinations []{*Pile, Weight}
	the list can be sorted into descending weight order

SOLVER
======
[ ] Score each baize
	percent complete
	number of free/used cells
	foundation percent complete
		13 x 4 = 52
		18 cards

[x] doing a Q makes autoCollect not work

put tapTargets in a map?
Baize.tapTargets = map[cardid.CardID] (dst?, weight, *savedBaize)
can't because Card will have >1 tapTarget

could use the undo stack to probe tap targets
and use another struct tree to record progress?
struct would have children, savableBaize, percentComplete ...
can move from current position to somewhere in the tree (auto move)

card has []tapTarget
tapTarget has *saveableBaize

try using the undo stack
	foreach tap target
		push current baize
		do move
find tap targets, moves on Baize0
foreach tap target
	clone Baize0 -> Baize1
	translate tap targets from Baize0 -> Baize1
	make move

for each tapDestination
	create/clone a child baize (Baize1) with depth+1, (and undoStack, fnNotify == nil)
	make a note of the card to be tapped
	make the tap move on Baize1
	if the Baize1 crc already exists, disregard
	?(record tapped card in Baize1)
	add Baize1 to taDestination
	if percentComplete == 100%, stop

find highest percentComplete in leaf node of tapTargets
	follow parent links, extra-highlighting tappedCard in each parent

Q&A
===
Q. Is the Baize transport object going to be *Baize or Baize?
A. *Baize

Q. Pile.Placeholder()
A. In LIGHT, this needs recreating everytime Pile.Label/Baize.Recycles is updated
	Stock is a special case (uses rune based on Baize.Recycles)
	Cell, Reserve are special cases (they draw nothing)
	LIGHT is going to need a switch Pile.Category

Q. Is Statistics LIGHT or DARK?
	Dark needs it for sorting "All by Played"
	Light needs it to display to user
	Dark knows when a game is complete, so it can record to json
A. DARK

Q. Are preferences LIGHT or DARK?
A. They are LIGHT
	But DARK must be told of PowerMoves
	SafeCollect, AutoCollect, can be API calls from Light to DARK

Q. MirrorBaize?
A. Entirely up to LIGHT, as the relative positions of piles don't change, only slot positions and fan type
	...implies need for LIGHT to hold copies of DARK Slot() and FanType()
	... may require help from DARK to do the undo push, restart, undo pop

Q. Start a new deal?
A.

Q. Change variant?
A.

Q. AutoCollect?
A. LIGHT can call Baize.Collect(safe bool) (replaces sol.Baize.AfterAfterUserMove)
	BUT
	Collect() should only be done while idle
	because Collect() is like the user doing a few card taps
	and so will invoke DARK AfterUserMove and LIGHT AfterMove

Q. DARK settings?
A. Maybe have a darkSettings struct
	containing PowerMoves, SafeCollect, AutoCollect?

